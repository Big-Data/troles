h1. Troles

Troles aims to be a complete (end-all) roles solution for Ruby and is also targeted to be used with Rails 3.
As of early June it is still under development but getting close to first release.
The project currently consists of: 

* Trole - for single role strategies 
* Troles - for many roles strategies

The Troles project uses _role caching_ to optimize performance! 
The roles list cache of a role subject (fx a user) is only updated (retrieved from data store) when the roles of the role subject changes!

Note: Troles is a full redesign of _roles generic_ and company, using lessons learned. Troles uses a much cleaner design. It is aimed at being easy to extend and easy to create adapters for etc.

h2. Status June 2, 2011

Trole and Troles are now mostly implemented. Looks like a very clean and intuitive design, and now fully documented!
The specs are mostly in place, but there is a need to test more usage of the APIs to ensure corner cases are covered
with ArgumentException raised and such. Also needs some debugging/finetuning in various places. 

I'm using "Yard":http://rubydoc.info/docs/yard/file/docs/GettingStarted.md for documentation.

<pre>$ yard server

From browser, go to: http://0.0.0.0:8808/  # then you can enjoy! the nice documentation :) 
</pre>

There is now support for Caching and invalidation of the _role_list_ when the roles change. 
The specs now validate that caching works as it should.

Please help out to finalize this project! :)

h2. Bug hunting by running specs

Run specs for at most one strategy at the time for now...

@$ rspec spec/troles/strategies/bit_many_spec.rb@ 

Please see the document _spec/Guide to running specs.textile_ where I advise on how best to do "bug hunting" to help get this project off the ground!

h2. Role strategies

The following lists the role strategies to be supported

* Single  - one role from a set of valid roles
* Many    - many roles from a set of valid roles 

h3. Single role strategies

Schemas:
* Boolean field on the User class (admin role)
* String field on the User class
* One reference to a Role
* Embeds one Role (document store only)

Field stored in the data store: @trole@

The field is named _trole_, in order not to conflict with the method _#role_ used in the _Role DSL_.

h3. Multiple roles strategies

Schemas
* Integer (bitmap) field on the User class
* String of comma delimited roles on User class
* References to multiple Roles
* Embeds multiple Roles

Field stored in the datastore: @troles@

The field is named troles, in order not to conflict with the method _#roles_ used in the _Role DSL_.

These strategies can be grouped and named as follows:

Single role:
* bit_one
* string_one
* ref_one
* embed_one (document store)

Multiple roles
* bit_many
* string_many
* ref_many
* embed_many (document store)

These strategies can be implemented for any data store using any schema format.

h3. Using roles strategies with Users and User accounts

Roles are assigned to role subject classes such as _User_ or _UserAccount_ (YES, Devise can have multiple user accounts!). The class that has a role strategy assigned is referred to as the _role subject class_. 
Different role subject classes can have different role strategies! 

When using Devise this could translate fx into a UserAccount with a "many roles" strategy and an AdminAccount with a "single role" strategy (or vice versa). 

Example:

<pre> 
  require 'troles'
  require 'troles/macros'
  
  class UserAccount
    troles_strategy(:string_many).configure!
  end

  class AdminAccount
    troles_strategy(:bit_one, :static => true).configure!
  end  
</pre>

The special troles macros must be enabled my requiring the _trole/macros_ file. 

h3. Macro options

The @:static => true@ options is used to indicate, that the role can not be changed after being initially set. 
But we are getting ahead of ourselves... (more on this later).
Troles can easily be extended to support other macro options if needed.

h2. Roles API

The Roles API can be divided into:

* Core
* Event/Cache
* Read
* Write
* Store
* Validation
* Operations object

There is an equivalen Trole API for single role strategies.

h3. Event/Cache API

The User class should have an event trigger after *save* to react when the roles have changed.
If the roles were changed, an even should be sent to an _Event Manager_ to handle this. The event manager
can have subscribers to events. 

Also any write event to the datastore should be predicated on _#static_roles?_ not being true for the user (thus ensuring guest roles are never updated).

Save triggers call to Event#update_roles
<pre>
User
  after_save: update_roles # event handler
</pre>

<pre>
module Troles::Api::Event
  def update_roles
  def publish_change event
</pre>

h3. Roles Read API

This API operates directly on a user, fx _user#has_role?_

<pre>  
  user.has_role? :admin
  user.is_role? :editor
  user.has_any_roles? :editor, :admin  
</pre>

h3. Roles Write API

This API operates directly on a user, fx _user#has_role?_

<pre>
  user.add_role :admin
  user.remove_role :editor
</pre>

h3. Roles Operations object

The Roles Operations object is available on user#roles

<pre>
  user.roles + :admin
  user.roles - :editor
  user.roles << [:editor, :admin]
  user.roles.clear!  
</pre>

h3. Creating a custom Strategy Storage Adapter (SSA)

Example custom SSA - encrypted comma seperated string for multiple roles:

You must implement the following methods:
- #display_roles (returns symbol list of roles)  
- #clear! (clear the role)
- #set_roles (set the roles in the datastore)

<pre>
module Trole::Storage
  module EncryptedStringOne < BaseOne
    def initialize role_subject        
      super
    end

    def display_roles
      decrypted_value.split(',')
    end

    # saves the role of the role subject in the data store
    # @param [Symbol] the role name
    def set_role role
      set_encrypted_ds_field role.to_s
    end  

    # sets the role to its default state
    def clear!
      set_encrypted_ds_field ""
    end  

    protected

    def decrypted_value
      ds_field_value.decrypt!
    end

    def set_encrypted_value value
      set_ds_field value.encrypt! 
    end
  end
end
</pre>  

h3. Custom Storage for an ORM (or data store)

For Active Record there is no need for change, as an AR Role model implements the _where_ API used in the default _#find_roles_ implementation of the generic _BaseMany_ storage.

<pre>
module Troles::Storage
  class BaseMany < Troles::Common::Storage
    def find_roles *roles
      role_model.where(:name => roles.flatten)
    end  
  ...
end
</pre>

However for Mongoid, there is a need to use _#all_ on the result of the query to get the array: 

@role_model_.where(:name => roles).all@

This can be done elegantly using super, and having the MongoidStorage inherit from the Generic one.

<pre>
module Troles::MongoidStorage
  class RefMany < Troles::Storage::BaseMany

    def find_roles *roles
      super(roles).all
    end
  ...  
</pre>

h3. Custom data marshaller

You can also use a custom "Marshaller":http://en.wikipedia.org/wiki/Marshalling_%28computer_science%29 to store the roles in a non-standard format. This is used for the _BitMany_ strategy, which has a special _Marshaller::BitMask_ class which handles conversion between a list of symbols to an _Integer_ bitmap representing it (relative to a valid roles list!). You can create your own _Marshaller_, fx to encrypt the roles info or whatever you like!

<pre>
module Troles::Marshaller
  class Encryption < Generic
    def initialize role_subject
      super
    end

    # convert marshalled value into roles symbols list
    def read
      ...      
    end

    # convert roles symbols list into value to be marshalled
    def write *roles
      ...
    end
  end
end
</pre>

h3. Custom troles strategy

To add a new strategy, create a special Strategy module that acts as the module included by the troles macro.
Using standard naming convention it will be found and used by the _troles_strategy_ macro method :)  
Configure the strategy to use your custom storage class. 

<pre>
module Troles::Strategy
  module EncryptedStringMany

    # What to add to the role subject class when this role strategy is included
    # @param [Class] the role subject class to  
    def self.included(base)
      base.send :include, BaseMany
      base.send :include, InstanceMethods
    end

    module InstanceMethods
      # The storage strategy class
      # @return [Class] a storage subclass
      def storage 
        Troles::Storage::EncryptedStringMany
      end
    end
  end
end  
</pre>

Note: By default if using/overriding the Generic strategy, the #generic? config attribute is set to true, which has the effect of adding an attr_accessor _:trole_ or _:troles_ to the role subject. To avoid this when implementing you own, non-generic role strategy set, set up your Config constructor to set generic to false:

<pre>
  module Troles::Mongoid
    module Strategy    
      module BaseMany
        # @param [Class] the role subject class for which to include the Role strategy (fx User Account)
        #
        def self.included(base)
          base.send :include, Troles::Strategy::BaseMany        
          base.extend Config         
        end

        module Config
          def troles_config
            @troles_config ||= Trole::Mongoid::Config.new self, :generic => :false
          end
        end
      end
    end
  end
</pre>

As an alternative to setting the generic to false via the Config initializer, try this: 
Define a method #generic? in your custom Config object which returns false always! (see example below)

See _Troles::Common::Config_ for more details.

An adapter requires a custom implementation of the Config class. It could look sth. like this for _Mongoid_:
<pre>
module Trole::Mongoid
  class Config < Troles::Common::Config  

    def initialize clazz, options = {}
      super
    end

    # This is NOT a generic strategy!
    def generic?
      false
    end
  
    def configure_relation
      case strategy
      when :ref_one
        clazz.send(:has_one, role_model_key, :class_name => role_model_class_name)
        role_model.send(:belongs_to, clazz_key, :class_name => clazz_name)
      when :embed_one
        clazz.send(:embeds_one, role_model_key, :class_name => role_model_class_name)      
      end
    end
    
    def configure_field
      type = case strategy
      when :bit_one
        Boolean
      when :string_one
        String
      end
      clazz.send(:field, role_field, type) if type      
    end
</pre>                     

As you can see, you have several nice convenience methods available to help set up these somewhat complex model relationships!

Configuring for Many roles strategies:

<pre>
module Troles::Mongoid
  class Config < Troles::Common::Config  

    def initialize clazz, options = {}
      super
    end
  
    def configure_relation
      case strategy
        ...
      end
    end
    
    def configure_field
      type = case strategy
      when :bit_many
        Integer
      when :string_many
        String
      end
      clazz.send(:field, role_field, type) if type      
    end
</pre>  

Very easy!

To use your adapter, simply pass an extra option to the troles_strategy macro:

<pre>
  User.troles_strategy(:bit_one, :orm => :mongoid).configure!
</pre> 

This even allows you to use different ORM role strategies/storages for different user accounts simultaneously!!!

Using the :auto_load option will 'auto load' (i.e require) the orm adapter from the built-in catalog of adapters that come with troles.
You can include a specific custom (or 3rd party) adapter manually. In the future it will be possible to configure troles with adapters 
and specify how/where to load them from as part of this configuration!

<pre>
  User.troles_strategy(:bit_one, :orm => :mongoid, :auto_load => true).configure!
</pre> 


In order to make the configuration even sweeter, the troles_strategy will yield the Config so you can configure it in a block, and when done simply call _configure!_

Here the ActiveRecord Config class has added an extra config property. 
This property can then be used in order to setup the join model between _User_ and _Role_ models for the M-M _RefMany_ scenario. 
Expanding the Config object this way as you see fit makes ORM configuration/customization much simpler!   

<pre>
User.troles_strategy :bit_one do |c|
  c.orm = :active_record
  c.role_model = 'Troll'
  c.role_join_model = 'UserTroll'
  c.auto_load = false
  c.valid_roles = [:troll, :warrior]
end.configure! 
</pre>

Enjoy :)

h2. License

This project rocks and uses MIT-LICENSE.