h1. Troles

Troles aims to be a complete (end-all) roles solution for Ruby and is also targeted to be used with Rails 3.
As of early June it is still under development but getting close to first release.
The project currently consists of: 

* Trole - for single role strategies 
* Troles - for many roles strategies

The Troles project uses _role caching_ to optimize performance! 
The roles list cache of a role subject (fx a user) is only updated (retrieved from data store) when the roles of the role subject changes!

Note: Troles is a full redesign of _roles generic_ and company, using lessons learned. Troles uses a much cleaner design. It is aimed at being easy to extend and easy to create adapters for etc.

h2. Status June 2, 2011

Trole and Troles are now mostly implemented. Looks like a very clean and intuitive design, and now fully documented!
The specs are mostly in place, but there is a need to test more usage of the APIs to ensure corner cases are covered
with ArgumentException raised and such. Also needs some debugging/finetuning in various places. 

I'm using "Yard":http://rubydoc.info/docs/yard/file/docs/GettingStarted.md for documentation.

<pre>$ yard server

From browser, go to: http://0.0.0.0:8808/  # then you can enjoy! the nice documentation :) 
</pre>

There is now support for Caching and invalidation of the _role_list_ when the roles change. 
The specs now validate that caching works as it should.

Please help out to finalize this project! :)

h2. Role strategies

The following lists the role strategies to be supported

* Single  - one role from a set of valid roles
* Many    - many roles from a set of valid roles 

h3. Single role strategies

Schemas:
* Boolean field on the User class (admin role)
* String field on the User class
* One reference to a Role
* Embeds one Role (document store only)

Field stored in the data store: @trole@

The field is named _trole_, in order not to conflict with the method _#role_ used in the _Role DSL_.

h3. Multiple roles strategies

Schemas
* Integer (bitmap) field on the User class
* String of comma delimited roles on User class
* References to multiple Roles
* Embeds multiple Roles

Field stored in the datastore: @troles@

The field is named troles, in order not to conflict with the method _#roles_ used in the _Role DSL_.

These strategies can be grouped and named as follows:

Single role:
* bit_one
* string_one
* ref_one
* embed_one (document store)

Multiple roles
* bit_many
* string_many
* ref_many
* embed_many (document store)

These strategies can be implemented for any data store using any schema format.

h3. Using roles strategies with Users and User accounts

Roles are assigned to role subject classes such as _User_ or _UserAccount_ (YES, Devise can have multiple user accounts!). The class that has a role strategy assigned is referred to as the _role subject class_. 
Different role subject classes can have different role strategies! 

When using Devise this could translate fx into a UserAccount with a "many roles" strategy and an AdminAccount with a "single role" strategy (or vice versa). 

Example:

<pre> 
  require 'troles'
  require 'troles/macros'
  
  class UserAccount
    troles_strategy :string_many
  end

  class AdminAccount
    troles_strategy :bit_one, :static => true
  end  
</pre>

The special troles macros must be enabled my requiring the _trole/macros_ file. 

h3. Macro options

The @:static => true@ options is used to indicate, that the role can not be changed after being initially set. 
But we are getting ahead of ourselves... (more on this later).
Troles can easily be extended to support other macro options if needed.

h2. Roles API

The Roles API can be divided into:

* Core
* Event/Cache
* Read
* Write
* Store
* Validation
* Operations object

There is an equivalen Trole API for single role strategies.

h3. Event/Cache API

The User class should have an event trigger after *save* to react when the roles have changed.
If the roles were changed, an even should be sent to an _Event Manager_ to handle this. The event manager
can have subscribers to events. 

Also any write event to the datastore should be predicated on _#static_roles?_ not being true for the user (thus ensuring guest roles are never updated).

Save triggers call to Event#update_roles
<pre>
User
  after_save: update_roles # event handler
</pre>

<pre>
module Troles::Api::Event
  def update_roles
  def publish_change event
</pre>

h3. Roles Read API

This API operates directly on a user, fx _user#has_role?_

<pre>  
  user.has_role? :admin
  user.is_role? :editor
  user.has_any_roles? :editor, :admin  
</pre>

h3. Roles Write API

This API operates directly on a user, fx _user#has_role?_

<pre>
  user.add_role :admin
  user.remove_role :editor
</pre>

h3. Roles Operations object

The Roles Operations object is available on user#roles

<pre>
  user.roles + :admin
  user.roles - :editor
  user.roles << [:editor, :admin]
  user.roles.clear!  
</pre>

h3. Creating a custom Strategy Storage Adapter (SSA)

Example custom SSA - encrypted comma seperated string for multiple roles:

<pre>
module Trole::Storage
  module EncryptedStringOne < BaseOne
    def initialize role_subject        
      super
    end

    def display_roles
      unencrypted_value.split(',')
    end

    # saves the role of the role subject in the data store
    # @param [Symbol] the role name
    def set_role role
      set_encrypted_ds_field role.to_s
    end  

    # sets the role to its default state
    def set_default_role!
      set_encrypted_ds_field ""
    end  

    protected

    def unencrypted_value
      ds_field_value.unencrypt!
    end

    def set_encrypted_value value
      set_ds_field value.encrypt! 
    end
  end
end
</pre>  

h3. Custom Storage for an ORM (or data store)

For Active Record there is no need for change, as an AR Role model implements the _where_ API used in the default _#find_roles_ implementation of the generic _BaseMany_ storage.

<pre>
module Troles::Storage
  class Generic < Troles::Common::Storage
    def find_roles *roles
      role_model_.where(:name => roles)
    end  
  ...
end
</pre>

However for Mongoid, there is a need to use _#all_ on the result of the query to get the array: 

@role_model_.where(:name => roles).all@

This can be done elegantly using super, and having the MongoidStorage inherit from the Generic one.

<pre>
module Troles::MongoidStorage
  class RefMany < Troles::Storage::BaseMany

    def find_roles *roles
      super.all
    end
  ...  
</pre>

h3. Custom data marshaller

You can also use a custom "Marshaller":http://en.wikipedia.org/wiki/Marshalling_%28computer_science%29 to store the roles in a non-standard format. This is used for the _BitMany_ strategy, which has a special _Marshaller::BitMask_ class which handles conversion between a list of symbols to an _Integer_ bitmap representing it (relative to a valid roles list!). You can create your own _Marshaller_, fx to encrypt the roles info or whatever you like!

<pre>
module Troles::Marshaller
  class Encryption < Generic
    def initialize role_subject
      super
    end

    # convert marshalled value into roles symbols list
    def read
      ...      
    end

    # convert roles symbols list into value to be marshalled
    def write *roles
      ...
    end
  end
end
</pre>

h3. Custom troles strategy

To add a new strategy, create a special Strategy module that acts as the module included by the troles macro.
Using standard naming convention it will be found and used by the _troles_strategy_ macro method :)  
Configure the strategy to use your custom storage class. 

<pre>
module Troles::Strategy
  module EncryptedStringMany

    # What to add to the role subject class when this role strategy is included
    # @param [Class] the role subject class to  
    def self.included(base)
      base.send :include, BaseMany
    end

    # The storage strategy class
    # @return [Class] a storage subclass
    def storage 
      Troles::Storage::EncryptedStringMany
    end      
  end
end
  
</pre>


h2. License

This project rocks and uses MIT-LICENSE.